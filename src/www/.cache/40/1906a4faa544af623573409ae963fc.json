{"id":"node_modules/libp2p-noise/dist/src/noise.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/noise.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"bcrypto/lib/js/x25519","loc":{"line":7,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/x25519.js"},{"name":"buffer","loc":{"line":8,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"it-pb-rpc","loc":{"line":9,"column":44},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/it-pb-rpc/src/index.js"},{"name":"it-pair/duplex","loc":{"line":10,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/it-pair/duplex.js"},{"name":"it-buffer","loc":{"line":11,"column":44},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/it-buffer/index.js"},{"name":"it-pipe","loc":{"line":12,"column":42},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/it-pipe/index.js"},{"name":"it-length-prefixed","loc":{"line":13,"column":37},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/it-length-prefixed/src/index.js"},{"name":"./handshake-xx","loc":{"line":14,"column":31},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js"},{"name":"./handshake-ik","loc":{"line":15,"column":31},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js"},{"name":"./handshake-xx-fallback","loc":{"line":16,"column":40},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js"},{"name":"./utils","loc":{"line":17,"column":24},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js"},{"name":"./encoder","loc":{"line":18,"column":26},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js"},{"name":"./crypto","loc":{"line":19,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/crypto.js"},{"name":"./keycache","loc":{"line":20,"column":27},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/keycache.js"},{"name":"./logger","loc":{"line":21,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js"},{"name":"./constants","loc":{"line":22,"column":28},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/noise.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/constants.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Noise = void 0;\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\nconst buffer_1 = require(\"buffer\");\nconst it_pb_rpc_1 = __importDefault(require(\"it-pb-rpc\"));\nconst duplex_1 = __importDefault(require(\"it-pair/duplex\"));\nconst it_buffer_1 = __importDefault(require(\"it-buffer\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst it_length_prefixed_1 = require(\"it-length-prefixed\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst handshake_ik_1 = require(\"./handshake-ik\");\nconst handshake_xx_fallback_1 = require(\"./handshake-xx-fallback\");\nconst utils_1 = require(\"./utils\");\nconst encoder_1 = require(\"./encoder\");\nconst crypto_1 = require(\"./crypto\");\nconst keycache_1 = require(\"./keycache\");\nconst logger_1 = require(\"./logger\");\nconst constants_1 = require(\"./constants\");\nclass Noise {\n    /**\n     *\n     * @param {bytes} staticNoiseKey x25519 private key, reuse for faster handshakes\n     * @param {bytes} earlyData\n     */\n    constructor(staticNoiseKey, earlyData) {\n        this.protocol = '/noise';\n        this.prologue = buffer_1.Buffer.alloc(0);\n        this.earlyData = earlyData || buffer_1.Buffer.alloc(0);\n        // disabled until properly specked\n        this.useNoisePipes = false;\n        if (staticNoiseKey) {\n            const publicKey = x25519_1.default.publicKeyCreate(staticNoiseKey);\n            this.staticKeys = {\n                privateKey: staticNoiseKey,\n                publicKey\n            };\n        }\n        else {\n            this.staticKeys = utils_1.generateKeypair();\n        }\n    }\n    /**\n     * Encrypt outgoing data to the remote party (handshake as initiator)\n     * @param {PeerId} localPeer - PeerId of the receiving peer\n     * @param {any} connection - streaming iterable duplex that will be encrypted\n     * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureOutbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            // wrong types in repo\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: true,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * Decrypt incoming data (handshake as responder).\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param {any} connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n    async secureInbound(localPeer, connection, remotePeer) {\n        const wrappedConnection = it_pb_rpc_1.default(connection, {\n            // wrong types in repo\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            lengthEncoder: encoder_1.uint16BEEncode,\n            lengthDecoder: encoder_1.uint16BEDecode,\n            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES\n        });\n        const handshake = await this.performHandshake({\n            connection: wrappedConnection,\n            isInitiator: false,\n            localPeer,\n            remotePeer\n        });\n        const conn = await this.createSecureConnection(wrappedConnection, handshake);\n        return {\n            conn,\n            remoteEarlyData: handshake.remoteEarlyData,\n            remotePeer: handshake.remotePeer\n        };\n    }\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     * @param {HandshakeParams} params\n     */\n    async performHandshake(params) {\n        const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n        let tryIK = this.useNoisePipes;\n        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {\n            // if we are initiator and remote static key is unknown, don't try IK\n            tryIK = false;\n        }\n        // Try IK if acting as responder or initiator that has remote's static key.\n        if (tryIK) {\n            // Try IK first\n            const { remotePeer, connection, isInitiator } = params;\n            const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, \n            // safe to cast as we did checks\n            keycache_1.KeyCache.load(params.remotePeer) || buffer_1.Buffer.alloc(32), remotePeer);\n            try {\n                return await this.performIKHandshake(ikHandshake);\n            }\n            catch (e) {\n                // IK failed, go to XX fallback\n                let ephemeralKeys;\n                if (params.isInitiator) {\n                    ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n                return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n            }\n        }\n        else {\n            // run XX handshake\n            return await this.performXXHandshake(params, payload);\n        }\n    }\n    async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n        }\n        catch (e) {\n            logger_1.logger(e);\n            throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);\n        }\n        return handshake;\n    }\n    async performXXHandshake(params, payload) {\n        const { isInitiator, remotePeer, connection } = params;\n        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n        try {\n            await handshake.propose();\n            await handshake.exchange();\n            await handshake.finish();\n            if (this.useNoisePipes && handshake.remotePeer) {\n                keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n            }\n        }\n        catch (e) {\n            throw new Error(`Error occurred during XX handshake: ${e.message}`);\n        }\n        return handshake;\n    }\n    async performIKHandshake(handshake) {\n        await handshake.stage0();\n        await handshake.stage1();\n        return handshake;\n    }\n    async createSecureConnection(connection, handshake) {\n        // Create encryption box/unbox wrapper\n        const [secure, user] = duplex_1.default();\n        const network = connection.unwrap();\n        await it_pipe_1.default(secure, // write to wrapper\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.encryptStream(handshake), // data is encrypted\n        it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), // prefix with message length\n        network, // send to the remote peer\n        it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), // read message length prefix\n        it_buffer_1.default, // ensure any type of data is converted to buffer\n        crypto_1.decryptStream(handshake), // decrypt the incoming data\n        secure // pipe to the wrapper\n        );\n        return user;\n    }\n}\nexports.Noise = Noise;\n"},"sourceMaps":{"js":{"version":3,"file":"noise.js","sourceRoot":"","sources":["../../src/noise.ts"],"names":[],"mappings":"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","sourcesContent":["import x25519 from 'bcrypto/lib/js/x25519'\nimport { Buffer } from 'buffer'\nimport Wrap from 'it-pb-rpc'\nimport DuplexPair from 'it-pair/duplex'\nimport ensureBuffer from 'it-buffer'\nimport pipe from 'it-pipe'\nimport { encode, decode } from 'it-length-prefixed'\n\nimport { XXHandshake } from './handshake-xx'\nimport { IKHandshake } from './handshake-ik'\nimport { XXFallbackHandshake } from './handshake-xx-fallback'\nimport { generateKeypair, getPayload } from './utils'\nimport { uint16BEDecode, uint16BEEncode } from './encoder'\nimport { decryptStream, encryptStream } from './crypto'\nimport { bytes } from './@types/basic'\nimport { INoiseConnection, KeyPair, SecureOutbound } from './@types/libp2p'\nimport { Duplex } from 'it-pair'\nimport { IHandshake } from './@types/handshake-interface'\nimport { KeyCache } from './keycache'\nimport { logger } from './logger'\nimport PeerId from 'peer-id'\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from './constants'\n\nexport type WrappedConnection = ReturnType<typeof Wrap>;\n\ntype HandshakeParams = {\n  connection: WrappedConnection;\n  isInitiator: boolean;\n  localPeer: PeerId;\n  remotePeer?: PeerId;\n};\n\nexport class Noise implements INoiseConnection {\n  public protocol = '/noise';\n\n  private readonly prologue = Buffer.alloc(0);\n  private readonly staticKeys: KeyPair;\n  private readonly earlyData?: bytes;\n  private useNoisePipes: boolean;\n\n  /**\n   *\n   * @param {bytes} staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param {bytes} earlyData\n   */\n  constructor (staticNoiseKey?: bytes, earlyData?: bytes) {\n    this.earlyData = earlyData || Buffer.alloc(0)\n    // disabled until properly specked\n    this.useNoisePipes = false\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey)\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey\n      }\n    } else {\n      this.staticKeys = generateKeypair()\n    }\n  }\n\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param {any} connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureOutbound (localPeer: PeerId, connection: any, remotePeer: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        // wrong types in repo\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param {any} connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n  public async secureInbound (localPeer: PeerId, connection: any, remotePeer?: PeerId): Promise<SecureOutbound> {\n    const wrappedConnection = Wrap(\n      connection,\n      {\n        // wrong types in repo\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        lengthEncoder: uint16BEEncode,\n        lengthDecoder: uint16BEDecode,\n        maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n      }\n    )\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    })\n    const conn = await this.createSecureConnection(wrappedConnection, handshake)\n\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    }\n  }\n\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param {HandshakeParams} params\n   */\n  private async performHandshake (params: HandshakeParams): Promise<IHandshake> {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData)\n    let tryIK = this.useNoisePipes\n    if (params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      // if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false\n    }\n    // Try IK if acting as responder or initiator that has remote's static key.\n    if (tryIK) {\n      // Try IK first\n      const { remotePeer, connection, isInitiator } = params\n      const ikHandshake = new IKHandshake(\n        isInitiator,\n        payload,\n        this.prologue,\n        this.staticKeys,\n        connection,\n        // safe to cast as we did checks\n        KeyCache.load(params.remotePeer) || Buffer.alloc(32),\n        remotePeer as PeerId\n      )\n\n      try {\n        return await this.performIKHandshake(ikHandshake)\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys()\n        }\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys)\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload)\n    }\n  }\n\n  private async performXXFallbackHandshake (\n    params: HandshakeParams,\n    payload: bytes,\n    initialMsg: bytes,\n    ephemeralKeys?: KeyPair\n  ): Promise<XXFallbackHandshake> {\n    const { isInitiator, remotePeer, connection } = params\n    const handshake =\n      new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys)\n\n    try {\n      await handshake.propose()\n      await handshake.exchange()\n      await handshake.finish()\n    } catch (e) {\n      logger(e)\n      throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`)\n    }\n\n    return handshake\n  }\n\n  private async performXXHandshake (\n    params: HandshakeParams,\n    payload: bytes\n  ): Promise<XXHandshake> {\n    const { isInitiator, remotePeer, connection } = params\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer)\n\n    try {\n      await handshake.propose()\n      await handshake.exchange()\n      await handshake.finish()\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey())\n      }\n    } catch (e) {\n      throw new Error(`Error occurred during XX handshake: ${e.message}`)\n    }\n\n    return handshake\n  }\n\n  private async performIKHandshake (\n    handshake: IKHandshake\n  ): Promise<IKHandshake> {\n    await handshake.stage0()\n    await handshake.stage1()\n\n    return handshake\n  }\n\n  private async createSecureConnection (\n    connection: WrappedConnection,\n    handshake: IHandshake\n  ): Promise<Duplex> {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair()\n    const network = connection.unwrap()\n\n    await pipe(\n      secure, // write to wrapper\n      ensureBuffer, // ensure any type of data is converted to buffer\n      encryptStream(handshake), // data is encrypted\n      encode({ lengthEncoder: uint16BEEncode }), // prefix with message length\n      network, // send to the remote peer\n      decode({ lengthDecoder: uint16BEDecode }), // read message length prefix\n      ensureBuffer, // ensure any type of data is converted to buffer\n      decryptStream(handshake), // decrypt the incoming data\n      secure // pipe to the wrapper\n    )\n\n    return user\n  }\n}\n"]}},"error":null,"hash":"74bad40758e66969dd6d3d67c15afb32","cacheData":{"env":{}}}