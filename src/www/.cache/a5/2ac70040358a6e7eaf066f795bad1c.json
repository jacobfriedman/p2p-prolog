{"id":"node_modules/libp2p-noise/dist/src/keycache.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/keycache.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/keycache.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyCache = void 0;\n/**\n * Storage for static keys of previously connected peers.\n */\nclass Keycache {\n    constructor() {\n        this.storage = new Map();\n    }\n    store(peerId, key) {\n        this.storage.set(peerId.id, key);\n    }\n    load(peerId) {\n        if (!peerId) {\n            return null;\n        }\n        return this.storage.get(peerId.id) || null;\n    }\n    resetStorage() {\n        this.storage.clear();\n    }\n}\nconst KeyCache = new Keycache();\nexports.KeyCache = KeyCache;\n"},"sourceMaps":{"js":{"version":3,"file":"keycache.js","sourceRoot":"","sources":["../../src/keycache.ts"],"names":[],"mappings":";;;AAGA;;GAEG;AACH,MAAM,QAAQ;IAAd;QACU,YAAO,GAAG,IAAI,GAAG,EAAuB,CAAC;IAgBnD,CAAC;IAdQ,KAAK,CAAE,MAAc,EAAE,GAAY;QACxC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA;IAClC,CAAC;IAEM,IAAI,CAAE,MAAe;QAC1B,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,IAAI,CAAA;SACZ;QACD,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,IAAI,CAAA;IAC5C,CAAC;IAEM,YAAY;QACjB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAA;IACtB,CAAC;CACF;AAED,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE,CAAA;AAE7B,4BAAQ","sourcesContent":["import { bytes32 } from './@types/basic'\nimport PeerId from 'peer-id'\n\n/**\n * Storage for static keys of previously connected peers.\n */\nclass Keycache {\n  private storage = new Map<Uint8Array, bytes32>();\n\n  public store (peerId: PeerId, key: bytes32): void {\n    this.storage.set(peerId.id, key)\n  }\n\n  public load (peerId?: PeerId): bytes32 | null {\n    if (!peerId) {\n      return null\n    }\n    return this.storage.get(peerId.id) || null\n  }\n\n  public resetStorage (): void {\n    this.storage.clear()\n  }\n}\n\nconst KeyCache = new Keycache()\nexport {\n  KeyCache\n}\n"]}},"error":null,"hash":"33f5592c2299cd5ac09bc446a6b52bd4","cacheData":{"env":{}}}