{"id":"node_modules/libp2p-noise/dist/src/handshake-xx.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/handshake-xx.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"buffer","loc":{"line":4,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"./handshakes/xx","loc":{"line":5,"column":21},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/xx.js"},{"name":"./utils","loc":{"line":6,"column":24},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js"},{"name":"./logger","loc":{"line":7,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js"},{"name":"./encoder","loc":{"line":8,"column":26},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst xx_1 = require(\"./handshakes/xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = payload;\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.xx = handshake || new xx_1.XX();\n        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    // stage 0\n    async propose() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        if (this.isInitiator) {\n            logger_1.logger('Stage 0 - Initiator starting to send first message.');\n            const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('Stage 0 - Initiator finished sending first message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n            const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());\n            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 0 validation fail');\n            }\n            logger_1.logger('Stage 0 - Responder received first message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n            const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 1 validation fail');\n            }\n            logger_1.logger('Stage 1 - Initiator received the message.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n    }\n    // stage 2\n    async finish() {\n        if (this.isInitiator) {\n            logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n            const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode2(messageBuffer));\n            logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n        }\n        else {\n            logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n            const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx handshake stage 2 validation fail');\n            }\n            logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                throw new Error(`Error occurred while verifying signed payload: ${e.message}`);\n            }\n        }\n        logger_1.logCipherState(this.session);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    getRemoteStaticKey() {\n        return this.session.hs.rs;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.XXHandshake = XXHandshake;\n"},"sourceMaps":{"js":{"version":3,"file":"handshake-xx.js","sourceRoot":"","sources":["../../src/handshake-xx.ts"],"names":[],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer'\n\nimport { XX } from './handshakes/xx'\nimport { KeyPair } from './@types/libp2p'\nimport { bytes, bytes32 } from './@types/basic'\nimport { NoiseSession } from './@types/handshake'\nimport { IHandshake } from './@types/handshake-interface'\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload\n} from './utils'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger'\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder'\nimport { WrappedConnection } from './noise'\nimport PeerId from 'peer-id'\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  protected payload: bytes;\n  protected connection: WrappedConnection;\n  protected xx: XX;\n  protected staticKeypair: KeyPair;\n\n  private prologue: bytes32;\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remotePeer?: PeerId,\n    handshake?: XX\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = payload\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.xx = handshake || new XX()\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  // stage 0\n  public async propose (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger('Stage 0 - Initiator starting to send first message.')\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0))\n      this.connection.writeLP(encode0(messageBuffer))\n      logger('Stage 0 - Initiator finished sending first message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger('Stage 0 - Responder waiting to receive first message...')\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice())\n      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 0 validation fail')\n      }\n      logger('Stage 0 - Responder received first message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...')\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 1 validation fail')\n      }\n      logger('Stage 1 - Initiator received the message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        this.remotePeer = await verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`)\n      }\n      logger('All good with the signature!')\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode1(messageBuffer))\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode2(messageBuffer))\n      logger('Stage 2 - Initiator sent message with signed payload.')\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...')\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 2 validation fail')\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.')\n\n      try {\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload: ${e.message}`)\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt (plaintext: bytes, session: NoiseSession): bytes {\n    const cs = this.getCS(session)\n\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext)\n  }\n\n  public decrypt (ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false)\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext)\n  }\n\n  public getRemoteStaticKey (): bytes {\n    return this.session.hs.rs\n  }\n\n  private getCS (session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  protected setRemoteEarlyData (data: Uint8Array|null|undefined): void {\n    if (data) {\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length)\n    }\n  }\n}\n"]}},"error":null,"hash":"8e39db443b94faaee199cc7e35c28849","cacheData":{"env":{}}}