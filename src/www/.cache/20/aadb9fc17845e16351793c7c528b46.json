{"id":"node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/handshakes/abstract-handshake.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"buffer","loc":{"line":7,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"bcrypto/lib/js/aead","loc":{"line":8,"column":39},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/aead.js"},{"name":"bcrypto/lib/js/x25519","loc":{"line":9,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/x25519.js"},{"name":"bcrypto/lib/js/sha256","loc":{"line":10,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/sha256.js"},{"name":"../utils","loc":{"line":11,"column":24},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js"},{"name":"../logger","loc":{"line":12,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\nconst buffer_1 = require(\"buffer\");\nconst aead_1 = __importDefault(require(\"bcrypto/lib/js/aead\"));\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\nconst utils_1 = require(\"../utils\");\nconst logger_1 = require(\"../logger\");\nexports.MIN_NONCE = 0;\nclass AbstractHandshake {\n    encryptWithAd(cs, ad, plaintext) {\n        const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return e;\n    }\n    decryptWithAd(cs, ad, ciphertext) {\n        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n        this.setNonce(cs, this.incrementNonce(cs.n));\n        return { plaintext, valid };\n    }\n    // Cipher state related\n    hasKey(cs) {\n        return !this.isEmptyKey(cs.k);\n    }\n    setNonce(cs, nonce) {\n        cs.n = nonce;\n    }\n    createEmptyKey() {\n        return buffer_1.Buffer.alloc(32);\n    }\n    isEmptyKey(k) {\n        const emptyKey = this.createEmptyKey();\n        return emptyKey.equals(k);\n    }\n    incrementNonce(n) {\n        return n + 1;\n    }\n    nonceToBytes(n) {\n        const nonce = buffer_1.Buffer.alloc(12);\n        nonce.writeUInt32LE(n, 4);\n        return nonce;\n    }\n    encrypt(k, n, ad, plaintext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new aead_1.default();\n        plaintext = buffer_1.Buffer.from(plaintext);\n        ctx.init(k, nonce);\n        ctx.aad(ad);\n        ctx.encrypt(plaintext);\n        // Encryption is done on the sent reference\n        return buffer_1.Buffer.concat([plaintext, ctx.final()]);\n    }\n    encryptAndHash(ss, plaintext) {\n        let ciphertext;\n        if (this.hasKey(ss.cs)) {\n            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n        }\n        else {\n            ciphertext = plaintext;\n        }\n        this.mixHash(ss, ciphertext);\n        return ciphertext;\n    }\n    decrypt(k, n, ad, ciphertext) {\n        const nonce = this.nonceToBytes(n);\n        const ctx = new aead_1.default();\n        ciphertext = buffer_1.Buffer.from(ciphertext);\n        const tag = ciphertext.slice(ciphertext.length - 16);\n        ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n        ctx.init(k, nonce);\n        ctx.aad(ad);\n        ctx.decrypt(ciphertext);\n        // Decryption is done on the sent reference\n        return { plaintext: ciphertext, valid: ctx.verify(tag) };\n    }\n    decryptAndHash(ss, ciphertext) {\n        let plaintext;\n        let valid = true;\n        if (this.hasKey(ss.cs)) {\n            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n        }\n        else {\n            plaintext = ciphertext;\n        }\n        this.mixHash(ss, ciphertext);\n        return { plaintext, valid };\n    }\n    dh(privateKey, publicKey) {\n        try {\n            const derived = x25519_1.default.derive(publicKey, privateKey);\n            const result = buffer_1.Buffer.alloc(32);\n            derived.copy(result);\n            return result;\n        }\n        catch (e) {\n            logger_1.logger(e.message);\n            return buffer_1.Buffer.alloc(32);\n        }\n    }\n    mixHash(ss, data) {\n        ss.h = this.getHash(ss.h, data);\n    }\n    getHash(a, b) {\n        return sha256_1.default.digest(buffer_1.Buffer.from([...a, ...b]));\n    }\n    mixKey(ss, ikm) {\n        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);\n        ss.cs = this.initializeKey(tempK);\n        ss.ck = ck;\n    }\n    initializeKey(k) {\n        const n = exports.MIN_NONCE;\n        return { k, n };\n    }\n    // Symmetric state related\n    initializeSymmetric(protocolName) {\n        const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n        const h = this.hashProtocolName(protocolNameBytes);\n        const ck = h;\n        const key = this.createEmptyKey();\n        const cs = this.initializeKey(key);\n        return { cs, ck, h };\n    }\n    hashProtocolName(protocolName) {\n        if (protocolName.length <= 32) {\n            const h = buffer_1.Buffer.alloc(32);\n            protocolName.copy(h);\n            return h;\n        }\n        else {\n            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n        }\n    }\n    split(ss) {\n        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));\n        const cs1 = this.initializeKey(tempk1);\n        const cs2 = this.initializeKey(tempk2);\n        return { cs1, cs2 };\n    }\n    writeMessageRegular(cs, payload) {\n        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n        const ne = this.createEmptyKey();\n        const ns = buffer_1.Buffer.alloc(0);\n        return { ne, ns, ciphertext };\n    }\n    readMessageRegular(cs, message) {\n        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n    }\n}\nexports.AbstractHandshake = AbstractHandshake;\n"},"sourceMaps":{"js":{"version":3,"file":"abstract-handshake.js","sourceRoot":"","sources":["../../../src/handshakes/abstract-handshake.ts"],"names":[],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer'\nimport AEAD from 'bcrypto/lib/js/aead'\nimport x25519 from 'bcrypto/lib/js/x25519'\nimport SHA256 from 'bcrypto/lib/js/sha256'\n\nimport { bytes, bytes32, uint32 } from '../@types/basic'\nimport { CipherState, MessageBuffer, SymmetricState } from '../@types/handshake'\nimport { getHkdf } from '../utils'\nimport { logger } from '../logger'\n\nexport const MIN_NONCE = 0\n\nexport abstract class AbstractHandshake {\n  public encryptWithAd (cs: CipherState, ad: bytes, plaintext: bytes): bytes {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext)\n    this.setNonce(cs, this.incrementNonce(cs.n))\n\n    return e\n  }\n\n  public decryptWithAd (cs: CipherState, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext)\n    this.setNonce(cs, this.incrementNonce(cs.n))\n\n    return { plaintext, valid }\n  }\n\n  // Cipher state related\n  protected hasKey (cs: CipherState): boolean {\n    return !this.isEmptyKey(cs.k)\n  }\n\n  protected setNonce (cs: CipherState, nonce: uint32): void {\n    cs.n = nonce\n  }\n\n  protected createEmptyKey (): bytes32 {\n    return Buffer.alloc(32)\n  }\n\n  protected isEmptyKey (k: bytes32): boolean {\n    const emptyKey = this.createEmptyKey()\n    return emptyKey.equals(k)\n  }\n\n  protected incrementNonce (n: uint32): uint32 {\n    return n + 1\n  }\n\n  protected nonceToBytes (n: uint32): bytes {\n    const nonce = Buffer.alloc(12)\n    nonce.writeUInt32LE(n, 4)\n\n    return nonce\n  }\n\n  protected encrypt (k: bytes32, n: uint32, ad: bytes, plaintext: bytes): bytes {\n    const nonce = this.nonceToBytes(n)\n    const ctx = new AEAD()\n    plaintext = Buffer.from(plaintext)\n    ctx.init(k, nonce)\n    ctx.aad(ad)\n    ctx.encrypt(plaintext)\n\n    // Encryption is done on the sent reference\n    return Buffer.concat([plaintext, ctx.final()])\n  }\n\n  protected encryptAndHash (ss: SymmetricState, plaintext: bytes): bytes {\n    let ciphertext\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext)\n    } else {\n      ciphertext = plaintext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return ciphertext\n  }\n\n  protected decrypt (k: bytes32, n: uint32, ad: bytes, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    const nonce = this.nonceToBytes(n)\n    const ctx = new AEAD()\n    ciphertext = Buffer.from(ciphertext)\n    const tag = ciphertext.slice(ciphertext.length - 16)\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16)\n    ctx.init(k, nonce)\n    ctx.aad(ad)\n    ctx.decrypt(ciphertext)\n    // Decryption is done on the sent reference\n    return { plaintext: ciphertext, valid: ctx.verify(tag) }\n  }\n\n  protected decryptAndHash (ss: SymmetricState, ciphertext: bytes): {plaintext: bytes; valid: boolean} {\n    let plaintext: bytes; let valid = true\n    if (this.hasKey(ss.cs)) {\n      ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext))\n    } else {\n      plaintext = ciphertext\n    }\n\n    this.mixHash(ss, ciphertext)\n    return { plaintext, valid }\n  }\n\n  protected dh (privateKey: bytes32, publicKey: bytes32): bytes32 {\n    try {\n      const derived = x25519.derive(publicKey, privateKey)\n      const result = Buffer.alloc(32)\n      derived.copy(result)\n      return result\n    } catch (e) {\n      logger(e.message)\n      return Buffer.alloc(32)\n    }\n  }\n\n  protected mixHash (ss: SymmetricState, data: bytes): void {\n    ss.h = this.getHash(ss.h, data)\n  }\n\n  protected getHash (a: bytes, b: bytes): bytes32 {\n    return SHA256.digest(Buffer.from([...a, ...b]))\n  }\n\n  protected mixKey (ss: SymmetricState, ikm: bytes32): void {\n    const [ck, tempK] = getHkdf(ss.ck, ikm)\n    ss.cs = this.initializeKey(tempK) as CipherState\n    ss.ck = ck\n  }\n\n  protected initializeKey (k: bytes32): CipherState {\n    const n = MIN_NONCE\n    return { k, n }\n  }\n\n  // Symmetric state related\n\n  protected initializeSymmetric (protocolName: string): SymmetricState {\n    const protocolNameBytes: bytes = Buffer.from(protocolName, 'utf-8')\n    const h = this.hashProtocolName(protocolNameBytes)\n\n    const ck = h\n    const key = this.createEmptyKey()\n    const cs: CipherState = this.initializeKey(key)\n\n    return { cs, ck, h }\n  }\n\n  protected hashProtocolName (protocolName: bytes): bytes32 {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32)\n      protocolName.copy(h)\n      return h\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0))\n    }\n  }\n\n  protected split (ss: SymmetricState): {cs1: CipherState, cs2: CipherState} {\n    const [tempk1, tempk2] = getHkdf(ss.ck, Buffer.alloc(0))\n    const cs1 = this.initializeKey(tempk1)\n    const cs2 = this.initializeKey(tempk2)\n\n    return { cs1, cs2 }\n  }\n\n  protected writeMessageRegular (cs: CipherState, payload: bytes): MessageBuffer {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload)\n    const ne = this.createEmptyKey()\n    const ns = Buffer.alloc(0)\n\n    return { ne, ns, ciphertext }\n  }\n\n  protected readMessageRegular (cs: CipherState, message: MessageBuffer): {plaintext: bytes; valid: boolean} {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext)\n  }\n}\n"]}},"error":null,"hash":"6ef778d7ec1d1ac7ade5678bf07b3987","cacheData":{"env":{}}}