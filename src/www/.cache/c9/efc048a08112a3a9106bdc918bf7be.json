{"id":"node_modules/libp2p-noise/dist/src/logger.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/logger.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"debug","loc":{"line":7,"column":40},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/debug/src/browser.js"},{"name":"./constants","loc":{"line":8,"column":28},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/constants.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logCipherState = exports.logRemoteEphemeralKey = exports.logRemoteStaticKey = exports.logLocalEphemeralKeys = exports.logLocalStaticKeys = exports.logger = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst constants_1 = require(\"./constants\");\nexports.logger = debug_1.default('libp2p:noise');\nlet keyLogger;\nif (constants_1.DUMP_SESSION_KEYS) {\n    keyLogger = exports.logger;\n}\nelse {\n    keyLogger = () => { };\n}\nfunction logLocalStaticKeys(s) {\n    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`);\n    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`);\n}\nexports.logLocalStaticKeys = logLocalStaticKeys;\nfunction logLocalEphemeralKeys(e) {\n    if (e) {\n        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`);\n        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`);\n    }\n    else {\n        keyLogger('Missing local ephemeral keys.');\n    }\n}\nexports.logLocalEphemeralKeys = logLocalEphemeralKeys;\nfunction logRemoteStaticKey(rs) {\n    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`);\n}\nexports.logRemoteStaticKey = logRemoteStaticKey;\nfunction logRemoteEphemeralKey(re) {\n    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`);\n}\nexports.logRemoteEphemeralKey = logRemoteEphemeralKey;\nfunction logCipherState(session) {\n    if (session.cs1 && session.cs2) {\n        keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`);\n        keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`);\n    }\n    else {\n        keyLogger('Missing cipher state.');\n    }\n}\nexports.logCipherState = logCipherState;\n"},"sourceMaps":{"js":{"version":3,"file":"logger.js","sourceRoot":"","sources":["../../src/logger.ts"],"names":[],"mappings":";;;;;;AAAA,kDAAyB;AACzB,2CAA+C;AAIlC,QAAA,MAAM,GAAG,eAAK,CAAC,cAAc,CAAC,CAAA;AAE3C,IAAI,SAAS,CAAA;AACb,IAAI,6BAAiB,EAAE;IACrB,SAAS,GAAG,cAAM,CAAA;CACnB;KAAM;IACL,SAAS,GAAG,GAAG,EAAE,GAAoB,CAAC,CAAA;CACvC;AAED,SAAgB,kBAAkB,CAAE,CAAU;IAC5C,SAAS,CAAC,2BAA2B,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;IACnE,SAAS,CAAC,4BAA4B,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;AACvE,CAAC;AAHD,gDAGC;AAED,SAAgB,qBAAqB,CAAE,CAAoB;IACzD,IAAI,CAAC,EAAE;QACL,SAAS,CAAC,8BAA8B,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;QACtE,SAAS,CAAC,+BAA+B,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;KACzE;SAAM;QACL,SAAS,CAAC,+BAA+B,CAAC,CAAA;KAC3C;AACH,CAAC;AAPD,sDAOC;AAED,SAAgB,kBAAkB,CAAE,EAAU;IAC5C,SAAS,CAAC,4BAA4B,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;AAC7D,CAAC;AAFD,gDAEC;AAED,SAAgB,qBAAqB,CAAE,EAAU;IAC/C,SAAS,CAAC,+BAA+B,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;AAChE,CAAC;AAFD,sDAEC;AAED,SAAgB,cAAc,CAAE,OAAqB;IACnD,IAAI,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,GAAG,EAAE;QAC9B,SAAS,CAAC,kBAAkB,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;QAC7E,SAAS,CAAC,kBAAkB,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAA;KAC9E;SAAM;QACL,SAAS,CAAC,uBAAuB,CAAC,CAAA;KACnC;AACH,CAAC;AAPD,wCAOC","sourcesContent":["import debug from 'debug'\nimport { DUMP_SESSION_KEYS } from './constants'\nimport { KeyPair } from './@types/libp2p'\nimport { NoiseSession } from './@types/handshake'\n\nexport const logger = debug('libp2p:noise')\n\nlet keyLogger\nif (DUMP_SESSION_KEYS) {\n  keyLogger = logger\n} else {\n  keyLogger = () => { /* do nothing */ }\n}\n\nexport function logLocalStaticKeys (s: KeyPair): void {\n  keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString('hex')}`)\n  keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString('hex')}`)\n}\n\nexport function logLocalEphemeralKeys (e: KeyPair|undefined): void {\n  if (e) {\n    keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString('hex')}`)\n    keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString('hex')}`)\n  } else {\n    keyLogger('Missing local ephemeral keys.')\n  }\n}\n\nexport function logRemoteStaticKey (rs: Buffer): void {\n  keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString('hex')}`)\n}\n\nexport function logRemoteEphemeralKey (re: Buffer): void {\n  keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString('hex')}`)\n}\n\nexport function logCipherState (session: NoiseSession): void {\n  if (session.cs1 && session.cs2) {\n    keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString('hex')}`)\n    keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString('hex')}`)\n  } else {\n    keyLogger('Missing cipher state.')\n  }\n}\n"]}},"error":null,"hash":"ea804a9a7a972d11e6ca832f58a54248","cacheData":{"env":{}}}