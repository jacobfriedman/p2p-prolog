{"id":"node_modules/libp2p-noise/dist/src/crypto.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/crypto.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/crypto.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"buffer","loc":{"line":4,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/crypto.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"./constants","loc":{"line":5,"column":28},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/crypto.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/constants.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptStream = exports.encryptStream = void 0;\nconst buffer_1 = require(\"buffer\");\nconst constants_1 = require(\"./constants\");\n// Returns generator that encrypts payload from the user\nfunction encryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n                yield data;\n            }\n        }\n    };\n}\nexports.encryptStream = encryptStream;\n// Decrypt received payload to the user\nfunction decryptStream(handshake) {\n    return async function* (source) {\n        for await (const chunk of source) {\n            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n                if (end > chunkBuffer.length) {\n                    end = chunkBuffer.length;\n                }\n                const chunk = chunkBuffer.slice(i, end);\n                const { plaintext: decrypted, valid } = await handshake.decrypt(chunk, handshake.session);\n                if (!valid) {\n                    throw new Error('Failed to validate decrypted chunk');\n                }\n                yield decrypted;\n            }\n        }\n    };\n}\nexports.decryptStream = decryptStream;\n"},"sourceMaps":{"js":{"version":3,"file":"crypto.js","sourceRoot":"","sources":["../../src/crypto.ts"],"names":[],"mappings":";;;AAAA,mCAA+B;AAE/B,2CAAgG;AAMhG,wDAAwD;AACxD,SAAgB,aAAa,CAAE,SAAqB;IAClD,OAAO,KAAK,SAAU,CAAC,EAAE,MAAM;QAC7B,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,MAAM,EAAE;YAChC,MAAM,WAAW,GAAG,eAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,MAAM,CAAC,CAAA;YAE7E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,IAAI,kDAAsC,EAAE;gBACnF,IAAI,GAAG,GAAG,CAAC,GAAG,kDAAsC,CAAA;gBACpD,IAAI,GAAG,GAAG,WAAW,CAAC,MAAM,EAAE;oBAC5B,GAAG,GAAG,WAAW,CAAC,MAAM,CAAA;iBACzB;gBAED,MAAM,IAAI,GAAG,SAAS,CAAC,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,SAAS,CAAC,OAAO,CAAC,CAAA;gBAC5E,MAAM,IAAI,CAAA;aACX;SACF;IACH,CAAC,CAAA;AACH,CAAC;AAhBD,sCAgBC;AAED,uCAAuC;AACvC,SAAgB,aAAa,CAAE,SAAqB;IAClD,OAAO,KAAK,SAAU,CAAC,EAAE,MAAM;QAC7B,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,MAAM,EAAE;YAChC,MAAM,WAAW,GAAG,eAAM,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,MAAM,CAAC,CAAA;YAE7E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,IAAI,sCAA0B,EAAE;gBACvE,IAAI,GAAG,GAAG,CAAC,GAAG,sCAA0B,CAAA;gBACxC,IAAI,GAAG,GAAG,WAAW,CAAC,MAAM,EAAE;oBAC5B,GAAG,GAAG,WAAW,CAAC,MAAM,CAAA;iBACzB;gBAED,MAAM,KAAK,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,CAAA;gBACvC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG,MAAM,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,SAAS,CAAC,OAAO,CAAC,CAAA;gBACzF,IAAI,CAAC,KAAK,EAAE;oBACV,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAA;iBACtD;gBACD,MAAM,SAAS,CAAA;aAChB;SACF;IACH,CAAC,CAAA;AACH,CAAC;AApBD,sCAoBC","sourcesContent":["import { Buffer } from 'buffer'\nimport { IHandshake } from './@types/handshake-interface'\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from './constants'\n\ninterface IReturnEncryptionWrapper {\n  (source: Iterable<Uint8Array>): AsyncIterableIterator<Uint8Array>;\n}\n\n// Returns generator that encrypts payload from the user\nexport function encryptStream (handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length)\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session)\n        yield data\n      }\n    }\n  }\n}\n\n// Decrypt received payload to the user\nexport function decryptStream (handshake: IHandshake): IReturnEncryptionWrapper {\n  return async function * (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length)\n\n      for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + NOISE_MSG_MAX_LENGTH_BYTES\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length\n        }\n\n        const chunk = chunkBuffer.slice(i, end)\n        const { plaintext: decrypted, valid } = await handshake.decrypt(chunk, handshake.session)\n        if (!valid) {\n          throw new Error('Failed to validate decrypted chunk')\n        }\n        yield decrypted\n      }\n    }\n  }\n}\n"]}},"error":null,"hash":"9267bfd141992275439a26e64cc9bf62","cacheData":{"env":{}}}