{"id":"node_modules/libp2p-noise/dist/src/handshake-ik.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/handshake-ik.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"./handshakes/ik","loc":{"line":4,"column":21},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshakes/ik.js"},{"name":"buffer","loc":{"line":5,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"./encoder","loc":{"line":6,"column":26},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js"},{"name":"./utils","loc":{"line":7,"column":24},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js"},{"name":"./errors","loc":{"line":8,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/errors.js"},{"name":"./logger","loc":{"line":9,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-ik.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IKHandshake = void 0;\nconst ik_1 = require(\"./handshakes/ik\");\nconst buffer_1 = require(\"buffer\");\nconst encoder_1 = require(\"./encoder\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst logger_1 = require(\"./logger\");\nclass IKHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n        this.isInitiator = isInitiator;\n        this.payload = buffer_1.Buffer.from(payload);\n        this.prologue = prologue;\n        this.staticKeypair = staticKeypair;\n        this.connection = connection;\n        if (remotePeer) {\n            this.remotePeer = remotePeer;\n        }\n        this.ik = handshake || new ik_1.IK();\n        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n        this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n    }\n    async stage0() {\n        logger_1.logLocalStaticKeys(this.session.hs.s);\n        logger_1.logRemoteStaticKey(this.session.hs.rs);\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 0 - Initiator sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode1(messageBuffer));\n            logger_1.logger('IK Stage 0 - Initiator sent message.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('IK Stage 0 - Responder receiving message...');\n            const receivedMsg = await this.connection.readLP();\n            try {\n                const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n                const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n                if (!valid) {\n                    throw new Error('ik handshake stage 0 decryption validation fail');\n                }\n                logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);\n            }\n        }\n    }\n    async stage1() {\n        if (this.isInitiator) {\n            logger_1.logger('IK Stage 1 - Initiator receiving message...');\n            const receivedMsg = (await this.connection.readLP()).slice();\n            const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);\n            logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n            try {\n                if (!valid) {\n                    throw new Error('ik stage 1 decryption validation fail');\n                }\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n                logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n                logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            }\n            catch (e) {\n                logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n                throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);\n            }\n        }\n        else {\n            logger_1.logger('IK Stage 1 - Responder sending message...');\n            const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n            this.connection.writeLP(encoder_1.encode0(messageBuffer));\n            logger_1.logger('IK Stage 1 - Responder sent message...');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        logger_1.logCipherState(this.session);\n    }\n    decrypt(ciphertext, session) {\n        const cs = this.getCS(session, false);\n        return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n    }\n    encrypt(plaintext, session) {\n        const cs = this.getCS(session);\n        return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n    }\n    getLocalEphemeralKeys() {\n        if (!this.session.hs.e) {\n            throw new Error('Ephemeral keys do not exist.');\n        }\n        return this.session.hs.e;\n    }\n    getCS(session, encryption = true) {\n        if (!session.cs1 || !session.cs2) {\n            throw new Error('Handshake not completed properly, cipher state does not exist.');\n        }\n        if (this.isInitiator) {\n            return encryption ? session.cs1 : session.cs2;\n        }\n        else {\n            return encryption ? session.cs2 : session.cs1;\n        }\n    }\n    setRemoteEarlyData(data) {\n        if (data) {\n            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n        }\n    }\n}\nexports.IKHandshake = IKHandshake;\n"},"sourceMaps":{"js":{"version":3,"file":"handshake-ik.js","sourceRoot":"","sources":["../../src/handshake-ik.ts"],"names":[],"mappings":"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","sourcesContent":["import { WrappedConnection } from './noise'\nimport { IK } from './handshakes/ik'\nimport { NoiseSession } from './@types/handshake'\nimport { bytes, bytes32 } from './@types/basic'\nimport { KeyPair } from './@types/libp2p'\nimport { IHandshake } from './@types/handshake-interface'\nimport { Buffer } from 'buffer'\nimport { decode0, decode1, encode0, encode1 } from './encoder'\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from './utils'\nimport { FailedIKError } from './errors'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logRemoteStaticKey,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logCipherState\n} from './logger'\nimport PeerId from 'peer-id'\n\nexport class IKHandshake implements IHandshake {\n  public isInitiator: boolean;\n  public session: NoiseSession;\n  public remotePeer!: PeerId;\n  public remoteEarlyData: Buffer;\n\n  private payload: bytes;\n  private prologue: bytes32;\n  private staticKeypair: KeyPair;\n  private connection: WrappedConnection;\n  private ik: IK;\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remoteStaticKey: bytes,\n    remotePeer?: PeerId,\n    handshake?: IK\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = Buffer.from(payload)\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.ik = handshake || new IK()\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey)\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  public async stage0 (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    logRemoteStaticKey(this.session.hs.rs)\n    if (this.isInitiator) {\n      logger('IK Stage 0 - Initiator sending message...')\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode1(messageBuffer))\n      logger('IK Stage 0 - Initiator sent message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger('IK Stage 0 - Responder receiving message...')\n      const receivedMsg = await this.connection.readLP()\n      try {\n        const receivedMessageBuffer = decode1(receivedMsg.slice())\n        const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer)\n        if (!valid) {\n          throw new Error('ik handshake stage 0 decryption validation fail')\n        }\n        logger('IK Stage 0 - Responder got message, going to verify payload.')\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n        logger('IK Stage 0 - Responder successfully verified payload!')\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger('Responder breaking up with IK handshake in stage 0.')\n\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`)\n      }\n    }\n  }\n\n  public async stage1 (): Promise<void> {\n    if (this.isInitiator) {\n      logger('IK Stage 1 - Initiator receiving message...')\n      const receivedMsg = (await this.connection.readLP()).slice()\n      const receivedMessageBuffer = decode0(Buffer.from(receivedMsg))\n      const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer)\n      logger('IK Stage 1 - Initiator got message, going to verify payload.')\n      try {\n        if (!valid) {\n          throw new Error('ik stage 1 decryption validation fail')\n        }\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n        logger('IK Stage 1 - Initiator successfully verified payload!')\n        logRemoteEphemeralKey(this.session.hs.re)\n      } catch (e) {\n        logger('Initiator breaking up with IK handshake in stage 1.')\n        throw new FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`)\n      }\n    } else {\n      logger('IK Stage 1 - Responder sending message...')\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode0(messageBuffer))\n      logger('IK Stage 1 - Responder sent message...')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n    logCipherState(this.session)\n  }\n\n  public decrypt (ciphertext: bytes, session: NoiseSession): {plaintext: bytes; valid: boolean} {\n    const cs = this.getCS(session, false)\n    return this.ik.decryptWithAd(cs, Buffer.alloc(0), ciphertext)\n  }\n\n  public encrypt (plaintext: Buffer, session: NoiseSession): Buffer {\n    const cs = this.getCS(session)\n    return this.ik.encryptWithAd(cs, Buffer.alloc(0), plaintext)\n  }\n\n  public getLocalEphemeralKeys (): KeyPair {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.')\n    }\n\n    return this.session.hs.e\n  }\n\n  private getCS (session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  private setRemoteEarlyData (data: Uint8Array|null|undefined): void {\n    if (data) {\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length)\n    }\n  }\n}\n"]}},"error":null,"hash":"26939fb2ba292c21d1c025b030e558c5","cacheData":{"env":{}}}