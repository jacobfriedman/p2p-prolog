{"id":"node_modules/libp2p-noise/dist/src/utils.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/utils.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"bcrypto/lib/hkdf","loc":{"line":7,"column":39},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/hkdf-browser.js"},{"name":"bcrypto/lib/js/x25519","loc":{"line":8,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/x25519.js"},{"name":"bcrypto/lib/js/sha256","loc":{"line":9,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/bcrypto/lib/js/sha256.js"},{"name":"buffer","loc":{"line":10,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"peer-id","loc":{"line":11,"column":42},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/peer-id/src/index.js"},{"name":"libp2p-crypto","loc":{"line":12,"column":32},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-crypto/src/index.js"},{"name":"./proto/payload","loc":{"line":13,"column":26},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/proto/payload.js"},{"name":"uint8arrays/equals","loc":{"line":14,"column":41},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/uint8arrays/equals.js"}],"generated":{"js":"\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\nconst hkdf_1 = __importDefault(require(\"bcrypto/lib/hkdf\"));\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\nconst buffer_1 = require(\"buffer\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\nconst payload_1 = require(\"./proto/payload\");\nconst equals_1 = __importDefault(require(\"uint8arrays/equals\"));\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\nfunction generateKeypair() {\n    const privateKey = x25519_1.default.privateKeyGenerate();\n    const publicKey = x25519_1.default.publicKeyCreate(privateKey);\n    return {\n        publicKey,\n        privateKey\n    };\n}\nexports.generateKeypair = generateKeypair;\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n    const earlyDataPayload = earlyData || buffer_1.Buffer.alloc(0);\n    return await createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\nexports.getPayload = getPayload;\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n    const payloadInit = NoiseHandshakePayloadProto.create({\n        identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n        identitySig: signedPayload,\n        data: earlyData || null\n    });\n    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\nexports.createHandshakePayload = createHandshakePayload;\nasync function signPayload(peerId, payload) {\n    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));\n}\nexports.signPayload = signPayload;\nasync function getPeerIdFromPayload(payload) {\n    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\nfunction decodePayload(payload) {\n    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\nexports.decodePayload = decodePayload;\nfunction getHandshakePayload(publicKey) {\n    return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\nexports.getHandshakePayload = getHandshakePayload;\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n    return equals_1.default(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n    const identityKey = buffer_1.Buffer.from(payload.identityKey);\n    if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n        throw new Error(\"Peer ID doesn't match libp2p public key.\");\n    }\n    const generatedPayload = getHandshakePayload(noiseStaticKey);\n    // Unmarshaling from PublicKey protobuf\n    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n        throw new Error(\"Static key doesn't match to peer that signed payload!\");\n    }\n    return peer_id_1.default.createFromPubKey(identityKey);\n}\nexports.verifySignedPayload = verifySignedPayload;\nfunction getHkdf(ck, ikm) {\n    const info = buffer_1.Buffer.alloc(0);\n    const prk = hkdf_1.default.extract(sha256_1.default, ikm, ck);\n    const okm = hkdf_1.default.expand(sha256_1.default, prk, info, 96);\n    const k1 = okm.slice(0, 32);\n    const k2 = okm.slice(32, 64);\n    const k3 = okm.slice(64, 96);\n    return [k1, k2, k3];\n}\nexports.getHkdf = getHkdf;\nfunction isValidPublicKey(pk) {\n    return x25519_1.default.publicKeyVerify(pk.slice(0, 32));\n}\nexports.isValidPublicKey = isValidPublicKey;\n"},"sourceMaps":{"js":{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import HKDF from 'bcrypto/lib/hkdf'\nimport x25519 from 'bcrypto/lib/js/x25519'\nimport SHA256 from 'bcrypto/lib/js/sha256'\nimport { Buffer } from 'buffer'\nimport PeerId from 'peer-id'\nimport { keys } from 'libp2p-crypto'\nimport { KeyPair } from './@types/libp2p'\nimport { bytes, bytes32 } from './@types/basic'\nimport { Hkdf, INoisePayload } from './@types/handshake'\nimport { pb } from './proto/payload'\nimport uint8ArrayEquals from 'uint8arrays/equals'\n\nconst NoiseHandshakePayloadProto = pb.NoiseHandshakePayload\n\nexport function generateKeypair (): KeyPair {\n  const privateKey = x25519.privateKeyGenerate()\n  const publicKey = x25519.publicKeyCreate(privateKey)\n\n  return {\n    publicKey,\n    privateKey\n  }\n}\n\nexport async function getPayload (\n  localPeer: PeerId,\n  staticPublicKey: bytes,\n  earlyData?: bytes\n): Promise<bytes> {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey))\n  const earlyDataPayload = earlyData || Buffer.alloc(0)\n\n  return await createHandshakePayload(\n    localPeer.marshalPubKey(),\n    signedPayload,\n    earlyDataPayload\n  )\n}\n\nexport function createHandshakePayload (\n  libp2pPublicKey: Uint8Array,\n  signedPayload: Uint8Array,\n  earlyData?: Uint8Array\n): bytes {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData || null\n  })\n\n  return Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish())\n}\n\nexport async function signPayload (peerId: PeerId, payload: bytes): Promise<bytes> {\n  return Buffer.from(await peerId.privKey.sign(payload))\n}\n\nexport async function getPeerIdFromPayload (payload: pb.INoiseHandshakePayload): Promise<PeerId> {\n  return await PeerId.createFromPubKey(Buffer.from(payload.identityKey as Uint8Array))\n}\n\nexport function decodePayload (payload: bytes|Uint8Array): pb.INoiseHandshakePayload {\n  return NoiseHandshakePayloadProto.toObject(\n    NoiseHandshakePayloadProto.decode(Buffer.from(payload))\n  ) as INoisePayload\n}\n\nexport function getHandshakePayload (publicKey: bytes): bytes {\n  return Buffer.concat([Buffer.from('noise-libp2p-static-key:'), publicKey])\n}\n\nasync function isValidPeerId (peerId: Uint8Array, publicKeyProtobuf: bytes) {\n  const generatedPeerId = await PeerId.createFromPubKey(publicKeyProtobuf)\n  return uint8ArrayEquals(generatedPeerId.id, peerId)\n}\n\n/**\n * Verifies signed payload, throws on any irregularities.\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\nexport async function verifySignedPayload (\n  noiseStaticKey: bytes,\n  payload: pb.INoiseHandshakePayload,\n  remotePeer: PeerId\n): Promise<PeerId> {\n  const identityKey = Buffer.from(payload.identityKey as Uint8Array)\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\")\n  }\n  const generatedPayload = getHandshakePayload(noiseStaticKey)\n  // Unmarshaling from PublicKey protobuf\n  const publicKey = keys.unmarshalPublicKey(identityKey)\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\")\n  }\n  return PeerId.createFromPubKey(identityKey)\n}\n\nexport function getHkdf (ck: bytes32, ikm: bytes): Hkdf {\n  const info = Buffer.alloc(0)\n  const prk = HKDF.extract(SHA256, ikm, ck)\n  const okm = HKDF.expand(SHA256, prk, info, 96)\n\n  const k1 = okm.slice(0, 32)\n  const k2 = okm.slice(32, 64)\n  const k3 = okm.slice(64, 96)\n\n  return [k1, k2, k3]\n}\n\nexport function isValidPublicKey (pk: bytes): boolean {\n  return x25519.publicKeyVerify(pk.slice(0, 32))\n}\n"]}},"error":null,"hash":"15e89d1565d84d6f3d8f5ca005a5d25e","cacheData":{"env":{}}}