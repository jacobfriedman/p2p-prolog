{"id":"node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/handshake-xx-fallback.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"buffer","loc":{"line":4,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"},{"name":"./handshake-xx","loc":{"line":5,"column":31},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx.js"},{"name":"./utils","loc":{"line":6,"column":24},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/utils.js"},{"name":"./logger","loc":{"line":7,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/logger.js"},{"name":"./encoder","loc":{"line":8,"column":26},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.XXFallbackHandshake = void 0;\nconst buffer_1 = require(\"buffer\");\nconst handshake_xx_1 = require(\"./handshake-xx\");\nconst utils_1 = require(\"./utils\");\nconst logger_1 = require(\"./logger\");\nconst encoder_1 = require(\"./encoder\");\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n    constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n        if (ephemeralKeys) {\n            this.ephemeralKeys = ephemeralKeys;\n        }\n        this.initialMsg = initialMsg;\n    }\n    // stage 0\n    // eslint-disable-next-line require-await\n    async propose() {\n        if (this.isInitiator) {\n            this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n            logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n            logger_1.logLocalEphemeralKeys(this.session.hs.e);\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n            const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n            const { valid } = this.xx.recvMessage(this.session, {\n                ne: receivedMessageBuffer.ne,\n                ns: buffer_1.Buffer.alloc(0),\n                ciphertext: buffer_1.Buffer.alloc(0)\n            });\n            if (!valid) {\n                throw new Error('xx fallback stage 0 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n        }\n    }\n    // stage 1\n    async exchange() {\n        if (this.isInitiator) {\n            const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n            if (!valid) {\n                throw new Error('xx fallback stage 1 decryption validation fail');\n            }\n            logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n            logger_1.logRemoteEphemeralKey(this.session.hs.re);\n            logger_1.logRemoteStaticKey(this.session.hs.rs);\n            logger_1.logger(\"Initiator going to check remote's signature...\");\n            try {\n                const decodedPayload = await utils_1.decodePayload(plaintext);\n                this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);\n                await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n                this.setRemoteEarlyData(decodedPayload.data);\n            }\n            catch (e) {\n                throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);\n            }\n            logger_1.logger('All good with the signature!');\n        }\n        else {\n            logger_1.logger('XX Fallback Stage 1 - Responder start');\n            await super.exchange();\n            logger_1.logger('XX Fallback Stage 1 - Responder end');\n        }\n    }\n}\nexports.XXFallbackHandshake = XXFallbackHandshake;\n"},"sourceMaps":{"js":{"version":3,"file":"handshake-xx-fallback.js","sourceRoot":"","sources":["../../src/handshake-xx-fallback.ts"],"names":[],"mappings":"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","sourcesContent":["import { Buffer } from 'buffer'\nimport { XXHandshake } from './handshake-xx'\nimport { XX } from './handshakes/xx'\nimport { KeyPair } from './@types/libp2p'\nimport { bytes, bytes32 } from './@types/basic'\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from './utils'\nimport { logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey } from './logger'\nimport { WrappedConnection } from './noise'\nimport { decode0, decode1 } from './encoder'\nimport PeerId from 'peer-id'\n\nexport class XXFallbackHandshake extends XXHandshake {\n  private ephemeralKeys?: KeyPair;\n  private initialMsg: bytes;\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    initialMsg: bytes,\n    remotePeer?: PeerId,\n    ephemeralKeys?: KeyPair,\n    handshake?: XX\n  ) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake)\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys\n    }\n    this.initialMsg = initialMsg\n  }\n\n  // stage 0\n  // eslint-disable-next-line require-await\n  public async propose (): Promise<void> {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys)\n      logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.')\n      const receivedMessageBuffer = decode0(this.initialMsg)\n      const { valid } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0)\n      })\n      if (!valid) {\n        throw new Error('xx fallback stage 0 decryption validation fail')\n      }\n      logger('XX Fallback Stage 0 - Responder used received message from IK.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg)\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx fallback stage 1 decryption validation fail')\n      }\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`)\n      }\n      logger('All good with the signature!')\n    } else {\n      logger('XX Fallback Stage 1 - Responder start')\n      await super.exchange()\n      logger('XX Fallback Stage 1 - Responder end')\n    }\n  }\n}\n"]}},"error":null,"hash":"d0b36e374d03bf71bd39b5673ab3ce13","cacheData":{"env":{}}}