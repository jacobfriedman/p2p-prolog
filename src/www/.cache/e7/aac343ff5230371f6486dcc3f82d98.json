{"id":"node_modules/libp2p-noise/dist/src/encoder.js","dependencies":[{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js.map","includedInParent":true,"mtime":1599134931000},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/src/encoder.ts","includedInParent":true,"mtime":1599134850000},{"name":"/home/jacob/projects/p2p-prolog/src/www/package.json","includedInParent":true,"mtime":1604858341685},{"name":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/package.json","includedInParent":true,"mtime":1604854764649},{"name":"buffer","loc":{"line":4,"column":25},"parent":"/home/jacob/projects/p2p-prolog/src/www/node_modules/libp2p-noise/dist/src/encoder.js","resolved":"/home/jacob/projects/p2p-prolog/src/www/node_modules/node-libs-browser/node_modules/buffer/index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;\nconst buffer_1 = require(\"buffer\");\nexports.uint16BEEncode = (value, target, offset) => {\n    target = target || buffer_1.Buffer.allocUnsafe(2);\n    target.writeUInt16BE(value, offset);\n    return target;\n};\nexports.uint16BEEncode.bytes = 2;\nexports.uint16BEDecode = (data) => {\n    if (data.length < 2)\n        throw RangeError('Could not decode int16BE');\n    return data.readUInt16BE(0);\n};\nexports.uint16BEDecode.bytes = 2;\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\nfunction encode0(message) {\n    return buffer_1.Buffer.concat([message.ne, message.ciphertext]);\n}\nexports.encode0 = encode0;\nfunction encode1(message) {\n    return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\nexports.encode1 = encode1;\nfunction encode2(message) {\n    return buffer_1.Buffer.concat([message.ns, message.ciphertext]);\n}\nexports.encode2 = encode2;\nfunction decode0(input) {\n    if (input.length < 32) {\n        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n    }\n    return {\n        ne: input.slice(0, 32),\n        ciphertext: input.slice(32, input.length),\n        ns: buffer_1.Buffer.alloc(0)\n    };\n}\nexports.decode0 = decode0;\nfunction decode1(input) {\n    if (input.length < 80) {\n        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n    }\n    return {\n        ne: input.slice(0, 32),\n        ns: input.slice(32, 80),\n        ciphertext: input.slice(80, input.length)\n    };\n}\nexports.decode1 = decode1;\nfunction decode2(input) {\n    if (input.length < 48) {\n        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n    }\n    return {\n        ne: buffer_1.Buffer.alloc(0),\n        ns: input.slice(0, 48),\n        ciphertext: input.slice(48, input.length)\n    };\n}\nexports.decode2 = decode2;\n"},"sourceMaps":{"js":{"version":3,"file":"encoder.js","sourceRoot":"","sources":["../../src/encoder.ts"],"names":[],"mappings":";;;AAAA,mCAA+B;AAKlB,QAAA,cAAc,GAAG,CAAC,KAAa,EAAE,MAAc,EAAE,MAAc,EAAU,EAAE;IACtF,MAAM,GAAG,MAAM,IAAI,eAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;IACxC,MAAM,CAAC,aAAa,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;IACnC,OAAO,MAAM,CAAA;AACf,CAAC,CAAA;AACD,sBAAc,CAAC,KAAK,GAAG,CAAC,CAAA;AAEX,QAAA,cAAc,GAAG,CAAC,IAAyB,EAAU,EAAE;IAClE,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;QAAE,MAAM,UAAU,CAAC,0BAA0B,CAAC,CAAA;IACjE,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAA;AAC7B,CAAC,CAAA;AACD,sBAAc,CAAC,KAAK,GAAG,CAAC,CAAA;AAExB,8FAA8F;AAE9F,SAAgB,OAAO,CAAE,OAAsB;IAC7C,OAAO,eAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC,CAAA;AACxD,CAAC;AAFD,0BAEC;AAED,SAAgB,OAAO,CAAE,OAAsB;IAC7C,OAAO,eAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC,CAAA;AACpE,CAAC;AAFD,0BAEC;AAED,SAAgB,OAAO,CAAE,OAAsB;IAC7C,OAAO,eAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC,CAAA;AACxD,CAAC;AAFD,0BAEC;AAED,SAAgB,OAAO,CAAE,KAAY;IACnC,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAA;KACnF;IAED,OAAO;QACL,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QACtB,UAAU,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,MAAM,CAAC;QACzC,EAAE,EAAE,eAAM,CAAC,KAAK,CAAC,CAAC,CAAC;KACpB,CAAA;AACH,CAAC;AAVD,0BAUC;AAED,SAAgB,OAAO,CAAE,KAAY;IACnC,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAA;KACnF;IAED,OAAO;QACL,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QACtB,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;QACvB,UAAU,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,MAAM,CAAC;KAC1C,CAAA;AACH,CAAC;AAVD,0BAUC;AAED,SAAgB,OAAO,CAAE,KAAY;IACnC,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;QACrB,MAAM,IAAI,KAAK,CAAC,iEAAiE,CAAC,CAAA;KACnF;IAED,OAAO;QACL,EAAE,EAAE,eAAM,CAAC,KAAK,CAAC,CAAC,CAAC;QACnB,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;QACtB,UAAU,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,MAAM,CAAC;KAC1C,CAAA;AACH,CAAC;AAVD,0BAUC","sourcesContent":["import { Buffer } from 'buffer'\nimport { bytes } from './@types/basic'\nimport { MessageBuffer } from './@types/handshake'\nimport BufferList from 'bl'\n\nexport const uint16BEEncode = (value: number, target: Buffer, offset: number): Buffer => {\n  target = target || Buffer.allocUnsafe(2)\n  target.writeUInt16BE(value, offset)\n  return target\n}\nuint16BEEncode.bytes = 2\n\nexport const uint16BEDecode = (data: Buffer | BufferList): number => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE')\n  return data.readUInt16BE(0)\n}\nuint16BEDecode.bytes = 2\n\n// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0 (message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ciphertext])\n}\n\nexport function encode1 (message: MessageBuffer): bytes {\n  return Buffer.concat([message.ne, message.ns, message.ciphertext])\n}\n\nexport function encode2 (message: MessageBuffer): bytes {\n  return Buffer.concat([message.ns, message.ciphertext])\n}\n\nexport function decode0 (input: bytes): MessageBuffer {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.')\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: Buffer.alloc(0)\n  }\n}\n\nexport function decode1 (input: bytes): MessageBuffer {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.')\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length)\n  }\n}\n\nexport function decode2 (input: bytes): MessageBuffer {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.')\n  }\n\n  return {\n    ne: Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length)\n  }\n}\n"]}},"error":null,"hash":"030c091568b4f082e16633f1b7c40cb1","cacheData":{"env":{}}}