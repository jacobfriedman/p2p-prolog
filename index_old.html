<!DOCTYPE html>
<!--
This is the test file for SWI-Prolog WebAssembly build.
It must be served through a web server. The web server
must use correct MIME type for wasm files.
Such simple-to-use web server is http-server:
<https://www.npmjs.com/package/http-server>
Install using npm i -g http-server
Run http-server command in the swipl-devel
directory and browse to <http://localhost:8080/src/wasm/test.html>
-->
<html>
    <head>
        <meta charset="UTF-8">
        <title>SWI-Prolog WebAssembly build test</title>
      
        <script>


        let bindings = null;
        let stdin = '';
        let stdinPosition = 0;
        // We use this to provide data into
        // the SWI stdin.
        const setStdin = (string) => {
            stdin = string;
            stdinPosition = 0;
        };
        const readStdin = () => {
            if (stdinPosition >= stdin.length) {
                return null;
            } else {
                const code = stdin.charCodeAt(stdinPosition);
                stdinPosition++;
                return code;
            }
        };


        class Prolog {

            constructor(module, args) {
                this.module = module;
                this.args = args;
                this.bindings = {};
                this._bind();
                this._initialise();     
            }

            // Creates bindings to the SWI foreign API.
            _bind() {
                this.bindings.PL_initialise = this.module.cwrap(
                    'PL_initialise', 'number', ['number', 'number']);
                this.bindings.PL_new_term_ref = this.module.cwrap(
                    'PL_new_term_ref', 'number', []);
                this.bindings.PL_chars_to_term = this.module.cwrap(
                    'PL_chars_to_term', 'number', ['string', 'number']);
                this.bindings.PL_call = this.module.cwrap(
                    'PL_call', 'number', ['number', 'number']);
            }

            // See http://www.swi-prolog.org/pldoc/doc_for?object=c(%27PL_initialise%27)
            _initialise() {
                const argv = this.args.map((arg) =>
                    this.module.allocate(
                        this.module.intArrayFromString(arg),
                        'i8', this.module.ALLOC_NORMAL));
                const ptr = this.module._malloc(argv.length * 4);
                argv.forEach((arg, i) => {
                    this.module.setValue(ptr + i * 4, arg, '*');
                });
                if (!this.bindings.PL_initialise(4, ptr)) {
                    throw new Error('SWI-Prolog initialisation failed.');
                }
                this.call_string("assert(user:file_search_path(library, 'wasm-preload/library')).");
            }

            // Helper function to parse a JavaScript
            // string into a Prolog term and call is as a query.
            call_string(query) {
                const ref = this.new_term_ref();
                if (!this.chars_to_term(query, ref)) {
                    throw new Error(`Query has a syntax error: ${query}.`);
                }
                return !!this.call(ref, 0);
            }

            // Return the arity of the given functor.
            functor_arity(functor) {
                return this.bindings.PL_functor_arity(functor);
            }

            // Return an atom representing the name of the given functor.
            functor_name(functor) {
                return this.bindings.PL_functor_name(functor);
            }

            // Returns functor of the given term.
            // Returns null when the term is not a compound.
            get_functor(term) {
                const ptr = this.module._malloc(4);
                if (this.bindings.PL_get_functor(term, ptr)) {
                    const functor = this.module.getValue(ptr, 'i32');
                    this.module._free(ptr);
                    return functor;
                } else {
                    this.module._free(ptr);
                    return null;
                }
            }

            // Returns integer number for the given term.
            // Returns null when the term is not an integer.
            get_integer(term) {
                const ptr = this.module._malloc(4);
                if (this.bindings.PL_get_integer(term, ptr)) {
                    const number = this.module.getValue(ptr, 'i32');
                    this.module._free(ptr);
                    return number;
                } else {
                    this.module._free(ptr);
                    return null;
                }
            }

            // Implements PL_put_chars for string case.
            put_chars_string(term, string) {
                const len = this.module.lengthBytesUTF8(string) + 1;
                const ptr = this.module._malloc(len);
                this.module.stringToUTF8(string, ptr, len);
                const ret = !!this.bindings.PL_put_chars(term, 5 | 0x1000, len - 1, ptr);
                this.module._free(ptr);
                return ret;
            }

            // Unifies the terms. Returns false if the terms
            // do not unify.
            unify(term1, term2) {
                return !!this.bindings.PL_unify(term1, term2);
            }

            // Returns whether the term is a string.
            is_string(term) {
                return !!this.bindings.PL_is_string(term);
            }

            // Return a C-string for the text represented by the given atom.
            atom_chars(atom) {
                const ptr = this.bindings.PL_atom_chars(atom);
                if (ptr === 0) {
                    return null;
                } else {
                    return this.module.Pointer_stringify(ptr);
                }
            }

            // Call term t just like the Prolog predicate once/1.
            call(term, module) {
                return this.bindings.PL_call(term, module);
            }

            // Parse the string chars and put the resulting
            // Prolog term into the term t.
            chars_to_term(query, t) {
                return this.bindings.PL_chars_to_term(query, t);
            }

            // Converts the argument term to a string.
            get_chars(term) {
                const ptr = this.module._malloc(4);
                const flags = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0080 | 0x1000 | 0x0200;
                if (this.bindings.PL_get_chars(term, ptr, flags)) {
                    // TODO properly free.
                    return this.module.UTF8ToString(this.module.getValue(ptr, 'i32'));
                } else {
                    return null;
                }
            }

            // If t is compound and index is between 1 and arity (inclusive),
            // assign a with a term reference to the argument.
            get_arg(index, term, arg) {
                return this.bindings.PL_get_arg(index, term, arg);
            }

            // Return an atom handle for the given C-string.
            new_atom(string) {
                return this.bindings.PL_new_atom(string);
            }

            // Returns a functor identifier, a handle for the name/arity pair.
            new_functor(atom, arity) {
                return this.bindings.PL_new_functor(atom, arity);
            }

            // Return a fresh reference to a term.
            new_term_ref() {
                return this.bindings.PL_new_term_ref();
            }

            // Create a new compound term from functor and bind t to this term.
            put_functor(term, functor) {        
                return this.bindings.PL_put_functor(term, functor);
            }

            // Unifies the index-th argument (1-based) of term with arg.
            unify_arg(index, term, arg) {
                return this.bindings.PL_unify_arg(index, term, arg);
            }
        }

                    // Helper to print stdout from SWI.
            const print = (line) => {
                console.log(line);
            };

                        // Helper to print stderr from SWI.
            const printErr = (line) => {
                new Error(line)
            };


          const query = (bindings, input) => {
                // Show the query in the console output.
                
                setStdin(input);
                // This will execute one iteration of toplevel.
                call(bindings, 'break'); // see call.js
            }
            

            const call = (bindings, query) => {
                const ref = bindings.PL_new_term_ref();
                if (!bindings.PL_chars_to_term(query, ref)) {
                    throw new Error('Query has a syntax error: ' + query);
                }
                return !!bindings.PL_call(ref, 0);
            };

        //
        //  
      /*  SWIPL({
            arguments: [
                'swipl',
                '-x', 'wasm-preload/boot.prc'
            ],
        }).then(async (module) => {

          console.log({module})

         const prolog = new Prolog(module, [
                        'swipl',
                        '-x', 'wasm-preload/swipl.prc',
                        '--nosignals'
                    ]);
                    */

                    // populate the actual Module object.



        const observer_config = { 
                attributes: true, 
                childList: true, 
                subtree: true, 
                characterData: true 
            }
                    
        /* const observer = new MutationObserver(
            (mutationList,observer) => {
                
                console.log(mutationList)

                let input = mutationList[0].target.textContent;

                module.FS.writeFile('/file.pl', input);
                query(bindings, "consult('/file.pl').");

                setStdin(input);
                // This will execute one iteration of toplevel.
                call(bindings, 'break'); // see call.js
*/
               /* out = prolog.call_string(
                    
                )
                console.log(out)
                */

            //}
       // )
       //     observer.observe(window.document, observer_config);
      //  })

        </script>
        <script src="swipl-web.js"></script>

        <script>

            // Creates bindings to the SWI foreign API.
            const createBindings = (module) => {
                return {
                    PL_initialise: module.cwrap('PL_initialise', 'number', ['number', 'number']),
                    PL_new_term_ref: module.cwrap('PL_new_term_ref', 'number', []),
                    PL_chars_to_term: module.cwrap('PL_chars_to_term', 'number', ['string', 'number']),
                    PL_call: module.cwrap('PL_call', 'number', ['number', 'number'])
                };
            };


            const initialise = (bindings, module) => {
                const argvArray = [
                    module.allocate(module.intArrayFromString('swipl'), 'i8', module.ALLOC_NORMAL),
                    module.allocate(module.intArrayFromString('-x'), 'i8', module.ALLOC_NORMAL),
                    module.allocate(module.intArrayFromString('wasm-preload/swipl.prc'), 'i8', module.ALLOC_NORMAL),
                    module.allocate(module.intArrayFromString('--nosignals'), 'i8', module.ALLOC_NORMAL)
                ];
                const argvPtr = module._malloc(argvArray.length * 4);
                for (let i = 0; i < argvArray.length; i++) {
                    module.setValue(argvPtr + i * 4, argvArray[i], '*');
                }
                if (!bindings.PL_initialise(4, argvPtr)) {
                    throw new Error('SWI-Prolog initialisation failed.');
                }
                // Set the path of the preloaded (from swipl-web.dat) standard library.
                // This makes it possible to call use_module(library(lists)) and so on.
                call(bindings, "assert(user:file_search_path(library, 'wasm-preload/library')).");
            };

            SWIPL({
                noInitialRun: true,
                print: print,
                printErr: printErr,
                preRun: [(module) => module.FS.init(readStdin)], // sets up stdin
                onRuntimeInitialized: (module) => {

                    console.log(module,'THEMODULE')

                    //document.getElementById('top').className = undefined;
                    // Bind foreign functions to JavaScript.
                    //bindings = createBindings(SWIPL);
                    // Initialise SWI-Prolog.
                    //initialise(bindings, SWIPL);
                }
            });

        </script>

        <style>

            html {
                padding:40px;
                font-family:monospace;
                filter:invert(1);
                background:black;
            }    
            body {
                white-space:pre-wrap;

            }
        </style>
    </head>

    <body contenteditable>
        :- use_module(library(lists)).

        %%    queens(+N, -Queens) is nondet.
        %
        %   @param  Queens is a list of column numbers for placing the queens.
        %   @author Richard A. O'Keefe (The Craft of Prolog)

        queens(N, Queens) :-
            length(Queens, N),
            board(Queens, Board, 0, N, _, _),
            queens(Board, 0, Queens).

        board([], [], N, N, _, _).
        board([_|Queens], [Col-Vars|Board], Col0, N, [_|VR], VC) :-
            Col is Col0+1,
            functor(Vars, f, N),
            constraints(N, Vars, VR, VC),
            board(Queens, Board, Col, N, VR, [_|VC]).

        constraints(0, _, _, _) :- !.
        constraints(N, Row, [R|Rs], [C|Cs]) :-
            arg(N, Row, R-C),
            M is N-1,
            constraints(M, Row, Rs, Cs).

        queens([], _, []).
        queens([C|Cs], Row0, [Col|Solution]) :-
            Row is Row0+1,
            select(Col-Vars, [C|Cs], Board),
            arg(Row, Vars, Row-Row),
            queens(Board, Row, Solution).
    </body>
</html>
